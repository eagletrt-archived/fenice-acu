ARM GAS  /tmp/ccePSTld.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"gps.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.checksum,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	checksum:
  25              	.LFB133:
  26              		.file 1 "Src/gps.c"
   1:Src/gps.c     **** #include "gps.h"
   2:Src/gps.c     **** 
   3:Src/gps.c     **** static int checksum(char *string_checksum, int size_string_checksum);
   4:Src/gps.c     **** int start_string_gps = 0;
   5:Src/gps.c     **** char string_gps[100];
   6:Src/gps.c     **** int cont_string, cont_comma;
   7:Src/gps.c     **** char data_string_gps;
   8:Src/gps.c     **** int msg_arrived_s = 0;
   9:Src/gps.c     **** extern char buffer_gps[50];
  10:Src/gps.c     **** extern int msg_arrived;
  11:Src/gps.c     **** extern gps_struct gps;
  12:Src/gps.c     **** extern char msg_gps[3];
  13:Src/gps.c     **** extern UART_HandleTypeDef huart2;
  14:Src/gps.c     **** 
  15:Src/gps.c     **** 
  16:Src/gps.c     **** int gps_init(UART_HandleTypeDef *huart, gps_struct *gps)
  17:Src/gps.c     **** { //initialization of GPS
  18:Src/gps.c     **** 
  19:Src/gps.c     **** 	//if return--> 0=error,1=ok
  20:Src/gps.c     **** 	huart->Init.BaudRate = 9600;
  21:Src/gps.c     ****     if (HAL_UART_DeInit(huart) != HAL_OK)
  22:Src/gps.c     ****     {
  23:Src/gps.c     ****         HAL_UART_Transmit(&huart2,(uint8_t*)"ERRORE 3\r\n",6,10);
  24:Src/gps.c     ****     }
  25:Src/gps.c     **** 	if (HAL_UART_Init(huart) != HAL_OK)
  26:Src/gps.c     ****     {
  27:Src/gps.c     ****         HAL_UART_Transmit(&huart2,(uint8_t*)"ERRORE 4\r\n",6,10);
  28:Src/gps.c     ****     }
  29:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_BAUD_115200, strlen(PMTK_SET_BAUD_115200), 200);
  30:Src/gps.c     **** 	HAL_Delay(500);
  31:Src/gps.c     **** 	/*huart->Init.BaudRate = 57600;
  32:Src/gps.c     ****     HAL_UART_DeInit(huart);
ARM GAS  /tmp/ccePSTld.s 			page 2


  33:Src/gps.c     **** 	HAL_UART_Init(huart);
  34:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_BAUD_115200, strlen(PMTK_SET_BAUD_115200), 200);
  35:Src/gps.c     **** 	HAL_Delay(500);
  36:Src/gps.c     ****     if (HAL_UART_DeInit(huart) != HAL_OK)
  37:Src/gps.c     ****     {
  38:Src/gps.c     ****         HAL_UART_Transmit(&huart2,(uint8_t*)"ERRORE 5\r\n",6,10);
  39:Src/gps.c     ****     }*/
  40:Src/gps.c     ****     huart->Init.BaudRate = 115200;
  41:Src/gps.c     **** 	if (HAL_UART_Init(huart) != HAL_OK)
  42:Src/gps.c     ****     {
  43:Src/gps.c     ****         HAL_UART_Transmit(&huart2,(uint8_t*)"ERRORE 6\r\n",6,10);
  44:Src/gps.c     ****     }
  45:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_BAUD_115200, strlen(PMTK_SET_BAUD_115200), 200);
  46:Src/gps.c     **** 	HAL_Delay(500);
  47:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_NMEA_UPDATE_10HZ, strlen(PMTK_SET_NMEA_UPDATE_10HZ), 
  48:Src/gps.c     **** 	HAL_Delay(500);
  49:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_NMEA_OUTPUT_GGAVTG, strlen(PMTK_SET_NMEA_OUTPUT_GGAVT
  50:Src/gps.c     **** 	HAL_Delay(500);
  51:Src/gps.c     **** 	strcpy(gps->speed, "000.00");
  52:Src/gps.c     **** 	strcpy(gps->latitude, "0000.0000");
  53:Src/gps.c     **** 	strcpy(gps->latitude_o, "N");
  54:Src/gps.c     **** 	strcpy(gps->longitude, "00000.0000");
  55:Src/gps.c     **** 	strcpy(gps->longitude_o, "W");
  56:Src/gps.c     **** 	strcpy(gps->altitude, "0000.0");
  57:Src/gps.c     **** 	strcpy(gps->hour, "00");
  58:Src/gps.c     ****     strcpy(gps->min, "00");
  59:Src/gps.c     ****     strcpy(gps->sec, "00");
  60:Src/gps.c     **** 	//HAL_UART_Receive_IT(huart, (uint8_t *)msg_gps, 1); //request of rx buffer interrupt
  61:Src/gps.c     **** 
  62:Src/gps.c     **** 	return 1;
  63:Src/gps.c     **** }
  64:Src/gps.c     **** 
  65:Src/gps.c     **** int gps_read(UART_HandleTypeDef *huart, gps_struct *gps)
  66:Src/gps.c     **** {
  67:Src/gps.c     **** 
  68:Src/gps.c     **** 	int ret = 0; //return--> 0=error,1=ok
  69:Src/gps.c     **** 
  70:Src/gps.c     **** 	/*
  71:Src/gps.c     **** 			* Example of strings
  72:Src/gps.c     **** 			* $GPGGA,064951.000,2307.1256,N,12016.4438,E,1,8,0.95,39.9,M,17.8,M,,*65
  73:Src/gps.c     **** 			* $GPGSA,A,3,29,21,26,15,18,09,06,10,,,,,2.32,0.95,2.11*00
  74:Src/gps.c     **** 			* $GPGSV,3,1,09,29,36,029,42,21,46,314,43,26,44,020,43,15,21,321,39*7D
  75:Src/gps.c     **** 			  $GPGSV,3,2,09,18,26,314,40,09,57,170,44,06,20,229,37,10,26,084,37*77
  76:Src/gps.c     **** 			  $GPGSV,3,3,09,07,,,26*73
  77:Src/gps.c     **** 			* $GPRMC,064951.000,A,2307.1256,N,12016.4438,E,0.03,165.48,260406,3.05,W,A*2C
  78:Src/gps.c     **** 			* $GPVTG,165.48,T,,M,0.03,N,0.06,K,A*37
  79:Src/gps.c     **** 			* $PGTOP,11,3 *6F
  80:Src/gps.c     **** 			*
  81:Src/gps.c     **** 			*
  82:Src/gps.c     **** 			*
  83:Src/gps.c     **** 			* 	$GPBOD - Bearing, origin to destination
  84:Src/gps.c     **** 				$GPBWC - Bearing and distance to waypoint, great circle
  85:Src/gps.c     **** 				$GPGGA - Global Positioning System Fix Data
  86:Src/gps.c     **** 				$GPGLL - Geographic position, latitude / longitude
  87:Src/gps.c     **** 				$GPGSA - GPS DOP and active satellites
  88:Src/gps.c     **** 				$GPGSV - GPS Satellites in view
  89:Src/gps.c     **** 				$GPHDT - Heading, True
ARM GAS  /tmp/ccePSTld.s 			page 3


  90:Src/gps.c     **** 				$GPR00 - List of waypoints in currently active route
  91:Src/gps.c     **** 				$GPRMA - Recommended minimum specific Loran-C data
  92:Src/gps.c     **** 				$GPRMB - Recommended minimum navigation info
  93:Src/gps.c     **** 				$GPRMC - Recommended minimum specific GPS/Transit data
  94:Src/gps.c     **** 				$GPRTE - Routes
  95:Src/gps.c     **** 				$GPTRF - Transit Fix Data
  96:Src/gps.c     **** 				$GPSTN - Multiple Data ID
  97:Src/gps.c     **** 				$GPVBW - Dual Ground / Water Speed
  98:Src/gps.c     **** 				$GPVTG - Track made good and ground speed
  99:Src/gps.c     **** 				$GPWPL - Waypoint location
 100:Src/gps.c     **** 				$GPXTE - Cross-track error, Measured
 101:Src/gps.c     **** 				$GPZDA - Date & Time
 102:Src/gps.c     **** 				http://aprs.gids.nl/nmea/
 103:Src/gps.c     **** 			*/
 104:Src/gps.c     ****     //check if it's the huart_gps interrupt
 105:Src/gps.c     ****     
 106:Src/gps.c     ****     char buffer_gps_s[50]; 
 107:Src/gps.c     ****     //HAL_UART_Transmit(&huart2,(uint8_t*)&buffer_gps[0],1,10);
 108:Src/gps.c     ****     if(msg_arrived > 0){
 109:Src/gps.c     ****         for(int i = 0; i < msg_arrived; i++){
 110:Src/gps.c     ****             buffer_gps_s[i] = buffer_gps[i];
 111:Src/gps.c     ****             //HAL_UART_Transmit(&huart2,(uint8_t*)&buffer_gps_s[i],1,10);
 112:Src/gps.c     ****         }
 113:Src/gps.c     ****         for(int j = 0; j < msg_arrived; j++){
 114:Src/gps.c     ****             data_string_gps = buffer_gps_s[j];
 115:Src/gps.c     ****             if ((start_string_gps == 1) && (data_string_gps != '$'))
 116:Src/gps.c     ****             {											   //check that the new string has not started yet
 117:Src/gps.c     ****                 string_gps[cont_string] = data_string_gps; //save the data into the array
 118:Src/gps.c     ****                 cont_string++;
 119:Src/gps.c     ****                 if (string_gps[cont_string - 2] == '\r' && string_gps[cont_string - 1] == '\n')
 120:Src/gps.c     ****                 { //indicates that the string is finishing
 121:Src/gps.c     ****                     cont_string = cont_string -2;
 122:Src/gps.c     ****                     string_gps[cont_string] = '\0'; // '\0'=end of the string
 123:Src/gps.c     ****                     start_string_gps = 0;	
 124:Src/gps.c     ****                     		//end of string
 125:Src/gps.c     ****                             char txt[100];
 126:Src/gps.c     ****                         sprintf(txt, "%s\r\n", string_gps);
 127:Src/gps.c     ****                         HAL_UART_Transmit(&huart2, (uint8_t*)txt, strlen(txt), 10);
 128:Src/gps.c     ****                     if (string_gps[2] == 'G' && string_gps[3] == 'G' && string_gps[4] == 'A')
 129:Src/gps.c     ****                     { // operation when the string is GPGGA //
 130:Src/gps.c     ****                         //memcpy(gps->string, "", 100);
 131:Src/gps.c     ****                         //memcpy(gps->string, string_gps, strlen(string_gps));
 132:Src/gps.c     **** 
 133:Src/gps.c     ****                         if (checksum(string_gps, cont_string) == 1)
 134:Src/gps.c     ****                         { //check the checksum (if==true -> enter)
 135:Src/gps.c     ****                             int cont_comma = 0, cont_latitude = 0, cont_longitude = 0, cont_altitud
 136:Src/gps.c     ****                             for (int i = 5; i < 100; i++)
 137:Src/gps.c     ****                             {
 138:Src/gps.c     ****                                 if (string_gps[i] == ',')
 139:Src/gps.c     ****                                     cont_comma++;
 140:Src/gps.c     ****                                 else
 141:Src/gps.c     ****                                 {
 142:Src/gps.c     ****                                     if (cont_comma == 1)
 143:Src/gps.c     ****                                     { //save the time
 144:Src/gps.c     ****                                         if(cont_time < 2){
 145:Src/gps.c     ****                                             gps->hour[cont_time] = string_gps[i];
 146:Src/gps.c     ****                                             cont_time++;
ARM GAS  /tmp/ccePSTld.s 			page 4


 147:Src/gps.c     ****                                         }else if(cont_time < 4){
 148:Src/gps.c     ****                                             gps->min[cont_time % 2] = string_gps[i];
 149:Src/gps.c     ****                                             cont_time++;
 150:Src/gps.c     ****                                         }else if(cont_time <6){
 151:Src/gps.c     ****                                             gps->sec[cont_time % 2] = string_gps[i];
 152:Src/gps.c     ****                                             cont_time++;
 153:Src/gps.c     ****                                         }
 154:Src/gps.c     ****                                         
 155:Src/gps.c     ****                                     }
 156:Src/gps.c     ****                                     else if (cont_comma == 2)
 157:Src/gps.c     ****                                     { //save latitude
 158:Src/gps.c     **** 
 159:Src/gps.c     ****                                         gps->latitude[cont_latitude] = string_gps[i];
 160:Src/gps.c     ****                                         cont_latitude++;
 161:Src/gps.c     ****                                     }
 162:Src/gps.c     ****                                     else if (cont_comma == 3)
 163:Src/gps.c     ****                                     { //save orientation of latitude
 164:Src/gps.c     ****                                         gps->latitude_o[0] = string_gps[i];
 165:Src/gps.c     ****                                     }
 166:Src/gps.c     ****                                     else if (cont_comma == 4)
 167:Src/gps.c     ****                                     { //save longitude
 168:Src/gps.c     ****                                         gps->longitude[cont_longitude] = string_gps[i];
 169:Src/gps.c     ****                                         cont_longitude++;
 170:Src/gps.c     ****                                     }
 171:Src/gps.c     ****                                     else if (cont_comma == 5)
 172:Src/gps.c     ****                                     { //save orientation of longitude
 173:Src/gps.c     ****                                         gps->longitude_o[0] = string_gps[i];
 174:Src/gps.c     ****                                     }
 175:Src/gps.c     ****                                     else if (cont_comma == 6)
 176:Src/gps.c     ****                                     {
 177:Src/gps.c     ****                                         gps->fix_status = string_gps[i];
 178:Src/gps.c     ****                                     }
 179:Src/gps.c     ****                                     else if (cont_comma == 9)
 180:Src/gps.c     ****                                     { //save altitude
 181:Src/gps.c     ****                                         gps->altitude[cont_altitude] = string_gps[i];
 182:Src/gps.c     ****                                         cont_altitude++;
 183:Src/gps.c     ****                                     }
 184:Src/gps.c     ****                                     else if (cont_comma == 10)
 185:Src/gps.c     ****                                     {
 186:Src/gps.c     ****                                         i = 100; //end the cicle
 187:Src/gps.c     ****                                     }
 188:Src/gps.c     ****                                 }
 189:Src/gps.c     ****                             }
 190:Src/gps.c     **** 
 191:Src/gps.c     ****                             //-- operation to split data and send them --//
 192:Src/gps.c     ****                             if (gps->fix_status == '0')
 193:Src/gps.c     ****                             {
 194:Src/gps.c     ****                                 char txt[100];
 195:Src/gps.c     ****                                 sprintf(txt,"\r\nNO CONNECTION\r\n");
 196:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 197:Src/gps.c     ****                                 gps->latitude_i_h = 0;
 198:Src/gps.c     ****                                 gps->latitude_i_l = 0;
 199:Src/gps.c     ****                                 gps->longitude_i_h = 0;
 200:Src/gps.c     ****                                 gps->longitude_i_l = 0;
 201:Src/gps.c     ****                                 gps->altitude_i = 0;
 202:Src/gps.c     ****                             }
 203:Src/gps.c     ****                             else
ARM GAS  /tmp/ccePSTld.s 			page 5


 204:Src/gps.c     ****                             {
 205:Src/gps.c     ****                                 char txt[100];
 206:Src/gps.c     ****                                 gps->latitude_i = (long int)(atof(gps->latitude) * 100);
 207:Src/gps.c     ****                                 sprintf(txt,"latitude %ld %c", gps->latitude_i, gps->latitude_o[0])
 208:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 209:Src/gps.c     ****                                 gps->longitude_i = (long int)(atof(gps->longitude) * 100);
 210:Src/gps.c     ****                                 sprintf(txt,"longitude %ld %c",gps->longitude_i, gps->longitude_o[0
 211:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 212:Src/gps.c     ****                                 sprintf(txt,"time %c%c:%c%c:%c%c", gps->hour[0], gps->hour[1], gps-
 213:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 214:Src/gps.c     ****                                 gps->altitude_i = (int)(atof(gps->altitude) * 10);
 215:Src/gps.c     ****                                 gps->latitude_i_h = (int)(gps->latitude_i >> 16);
 216:Src/gps.c     ****                                 gps->latitude_i_l = (int)(gps->latitude_i - (gps->latitude_i_h << 1
 217:Src/gps.c     ****                                 gps->longitude_i_h = (int)(gps->longitude_i >> 16);
 218:Src/gps.c     ****                                 gps->longitude_i_l = (int)(gps->longitude_i - (gps->longitude_i_h <
 219:Src/gps.c     ****                             }
 220:Src/gps.c     ****                             ret = 1;
 221:Src/gps.c     ****                         }
 222:Src/gps.c     ****                         else
 223:Src/gps.c     ****                         {
 224:Src/gps.c     ****                             char txt[100];
 225:Src/gps.c     ****                             sprintf(txt,"\r\nCHECKSUM FAIL\r\n");
 226:Src/gps.c     ****                             HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 227:Src/gps.c     ****                             ret = 0; //checksum failed
 228:Src/gps.c     ****                         }
 229:Src/gps.c     ****                     }
 230:Src/gps.c     ****                     else if (string_gps[2] == 'V' && string_gps[3] == 'T' && string_gps[4] == 'G')
 231:Src/gps.c     ****                     { // operation when the string is GPVTG //
 232:Src/gps.c     ****                         
 233:Src/gps.c     ****                         if (checksum(string_gps, cont_string) == 1)
 234:Src/gps.c     ****                         { //check the checksum (if==true -> enter)
 235:Src/gps.c     ****                             cont_comma = 0;
 236:Src/gps.c     ****                             int cont_speed = 0;
 237:Src/gps.c     ****                             int cont_true_track_mode = 0;
 238:Src/gps.c     ****                             for (int i = 5; i < cont_string; i++)
 239:Src/gps.c     ****                             {
 240:Src/gps.c     ****                                 if (string_gps[i] == ',')
 241:Src/gps.c     ****                                     cont_comma++;
 242:Src/gps.c     ****                                 else
 243:Src/gps.c     ****                                 {
 244:Src/gps.c     ****                                     if (cont_comma == 1){
 245:Src/gps.c     ****                                         gps->true_track_mode[cont_true_track_mode] = string_gps[i];
 246:Src/gps.c     ****                                         cont_true_track_mode++;
 247:Src/gps.c     ****                                     }
 248:Src/gps.c     ****                                     else if (cont_comma == 7)
 249:Src/gps.c     ****                                     { //save the speed
 250:Src/gps.c     ****                                         gps->speed[cont_speed] = string_gps[i];
 251:Src/gps.c     ****                                         cont_speed++;
 252:Src/gps.c     ****                                     }
 253:Src/gps.c     ****                                     else if (cont_comma == 8)
 254:Src/gps.c     ****                                     {
 255:Src/gps.c     ****                                         i = cont_string;
 256:Src/gps.c     ****                                     }
 257:Src/gps.c     ****                                 }
 258:Src/gps.c     ****                             }
 259:Src/gps.c     ****                             //-- operation to split data and send them --//
 260:Src/gps.c     ****                             if (gps->fix_status == '0')
ARM GAS  /tmp/ccePSTld.s 			page 6


 261:Src/gps.c     ****                             {
 262:Src/gps.c     ****                                 char txt[100];
 263:Src/gps.c     ****                                 sprintf(txt,"\r\nNO CONNECTION\r\n");
 264:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 265:Src/gps.c     ****                                 gps->speed_i = 0;
 266:Src/gps.c     ****                             }
 267:Src/gps.c     ****                             else
 268:Src/gps.c     ****                             {
 269:Src/gps.c     ****                                 char txt[100];
 270:Src/gps.c     ****                                 gps->speed_i = (int)(atof(gps->speed) * 100);
 271:Src/gps.c     ****                                 gps->true_track_mode_i = (int)(atof(gps->true_track_mode)*10);
 272:Src/gps.c     ****                                 
 273:Src/gps.c     ****                                 sprintf(txt,"speed: %d",gps->speed_i);
 274:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 275:Src/gps.c     ****                             }
 276:Src/gps.c     **** 
 277:Src/gps.c     ****                             ret = 1;
 278:Src/gps.c     ****                         }
 279:Src/gps.c     ****                         else
 280:Src/gps.c     ****                         {
 281:Src/gps.c     ****                             char txt[100];
 282:Src/gps.c     ****                             sprintf(txt,"\r\nCHECKSUM FAIL\r\n");
 283:Src/gps.c     ****                             HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 284:Src/gps.c     ****                             ret = 0; //checksum failed
 285:Src/gps.c     ****                         }
 286:Src/gps.c     ****                     }
 287:Src/gps.c     ****                     strcpy(string_gps, "");
 288:Src/gps.c     ****                     cont_string = 0;
 289:Src/gps.c     **** 
 290:Src/gps.c     ****                     
 291:Src/gps.c     ****                     
 292:Src/gps.c     ****                 }
 293:Src/gps.c     ****             }
 294:Src/gps.c     ****             else
 295:Src/gps.c     ****             {
 296:Src/gps.c     ****                 if (data_string_gps == '$')
 297:Src/gps.c     ****                 {						  //check if data indicates the start of new string
 298:Src/gps.c     ****                     start_string_gps = 1; //new string started
 299:Src/gps.c     ****                     cont_string = 0;	  //set the counter to 1
 300:Src/gps.c     ****                 }
 301:Src/gps.c     ****             }
 302:Src/gps.c     ****         }
 303:Src/gps.c     ****         msg_arrived = 0;
 304:Src/gps.c     ****         //data_string_gps = buffer_gps[0];						  //convert a pointer into a char
 305:Src/gps.c     ****     }
 306:Src/gps.c     **** 	return ret;
 307:Src/gps.c     **** }
 308:Src/gps.c     **** static int checksum(char *string_checksum, int size_string_checksum)
 309:Src/gps.c     **** { //check the checksum
  27              		.loc 1 309 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 70B5     		push	{r4, r5, r6, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccePSTld.s 			page 7


  35              		.cfi_offset 4, -16
  36              		.cfi_offset 5, -12
  37              		.cfi_offset 6, -8
  38              		.cfi_offset 14, -4
  39 0002 82B0     		sub	sp, sp, #8
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 24
  42              	.LVL1:
 310:Src/gps.c     **** 	//return 1;
 311:Src/gps.c     **** 
 312:Src/gps.c     **** 	int res = 0;
 313:Src/gps.c     **** 	int offset_maiusc = (int)('A') - (int)('a');
 314:Src/gps.c     **** 	int i = 0;
 315:Src/gps.c     ****     string_checksum[0] = 'G';
  43              		.loc 1 315 0
  44 0004 4723     		movs	r3, #71
  45 0006 0370     		strb	r3, [r0]
 316:Src/gps.c     ****     string_checksum[1] = 'P';
  46              		.loc 1 316 0
  47 0008 5023     		movs	r3, #80
  48 000a 4370     		strb	r3, [r0, #1]
 317:Src/gps.c     **** 
 318:Src/gps.c     **** 	for (i = 0; (i < size_string_checksum) && (string_checksum[i] != '*'); i++)
  49              		.loc 1 318 0
  50 000c 0023     		movs	r3, #0
 312:Src/gps.c     **** 	int offset_maiusc = (int)('A') - (int)('a');
  51              		.loc 1 312 0
  52 000e 1C46     		mov	r4, r3
  53              		.loc 1 318 0
  54 0010 01E0     		b	.L2
  55              	.LVL2:
  56              	.L4:
 319:Src/gps.c     **** 	{
 320:Src/gps.c     **** 		res = res ^ string_checksum[i];
  57              		.loc 1 320 0 discriminator 4
  58 0012 5440     		eors	r4, r4, r2
  59              	.LVL3:
 318:Src/gps.c     **** 	{
  60              		.loc 1 318 0 discriminator 4
  61 0014 0133     		adds	r3, r3, #1
  62              	.LVL4:
  63              	.L2:
 318:Src/gps.c     **** 	{
  64              		.loc 1 318 0 is_stmt 0 discriminator 1
  65 0016 8B42     		cmp	r3, r1
  66 0018 02DA     		bge	.L3
 318:Src/gps.c     **** 	{
  67              		.loc 1 318 0 discriminator 3
  68 001a C25C     		ldrb	r2, [r0, r3]	@ zero_extendqisi2
  69 001c 2A2A     		cmp	r2, #42
  70 001e F8D1     		bne	.L4
  71              	.L3:
 321:Src/gps.c     **** 	}
 322:Src/gps.c     **** 	char check[2] = {string_checksum[i + 1], string_checksum[i + 2]};
  72              		.loc 1 322 0 is_stmt 1
  73 0020 1844     		add	r0, r0, r3
  74              	.LVL5:
ARM GAS  /tmp/ccePSTld.s 			page 8


  75 0022 4578     		ldrb	r5, [r0, #1]	@ zero_extendqisi2
  76 0024 8678     		ldrb	r6, [r0, #2]	@ zero_extendqisi2
 323:Src/gps.c     **** 	char res_char[3];
 324:Src/gps.c     **** 	sprintf(res_char, "  %x  ", res);
  77              		.loc 1 324 0
  78 0026 2246     		mov	r2, r4
  79 0028 1C49     		ldr	r1, .L15
  80              	.LVL6:
  81 002a 01A8     		add	r0, sp, #4
  82 002c FFF7FEFF 		bl	sprintf
  83              	.LVL7:
 325:Src/gps.c     ****     //HAL_UART_Transmit(&huart2, (uint8_t*)string_checksum, size_string_checksum, 10);
 326:Src/gps.c     ****     HAL_UART_Transmit(&huart2, (uint8_t*)res_char, strlen(res_char), 10);
  84              		.loc 1 326 0
  85 0030 01A8     		add	r0, sp, #4
  86 0032 FFF7FEFF 		bl	strlen
  87              	.LVL8:
  88 0036 0A23     		movs	r3, #10
  89 0038 82B2     		uxth	r2, r0
  90 003a 01A9     		add	r1, sp, #4
  91 003c 1848     		ldr	r0, .L15+4
  92 003e FFF7FEFF 		bl	HAL_UART_Transmit
  93              	.LVL9:
 327:Src/gps.c     **** 	if (res < 17)
  94              		.loc 1 327 0
  95 0042 102C     		cmp	r4, #16
  96 0044 06DC     		bgt	.L5
 328:Src/gps.c     **** 	{
 329:Src/gps.c     **** 		res_char[1] = res_char[0];
  97              		.loc 1 329 0
  98 0046 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
  99 004a 8DF80530 		strb	r3, [sp, #5]
 330:Src/gps.c     **** 		res_char[0] = '0';
 100              		.loc 1 330 0
 101 004e 3023     		movs	r3, #48
 102 0050 8DF80430 		strb	r3, [sp, #4]
 103              	.L5:
 312:Src/gps.c     **** 	int offset_maiusc = (int)('A') - (int)('a');
 104              		.loc 1 312 0 discriminator 1
 105 0054 0023     		movs	r3, #0
 106 0056 00E0     		b	.L6
 107              	.LVL10:
 108              	.L7:
 109              	.LBB2:
 331:Src/gps.c     **** 	}
 332:Src/gps.c     **** 	for (int j = 0; j < 2; j++)
 110              		.loc 1 332 0 discriminator 2
 111 0058 0133     		adds	r3, r3, #1
 112              	.LVL11:
 113              	.L6:
 114              		.loc 1 332 0 is_stmt 0 discriminator 1
 115 005a 012B     		cmp	r3, #1
 116 005c 0EDC     		bgt	.L13
 333:Src/gps.c     **** 	{ //convert to upper case letter
 334:Src/gps.c     **** 		if ((int)res_char[j] >= 'a' && (int)res_char[j] <= 'f')
 117              		.loc 1 334 0 is_stmt 1
 118 005e 02AA     		add	r2, sp, #8
ARM GAS  /tmp/ccePSTld.s 			page 9


 119 0060 1A44     		add	r2, r2, r3
 120 0062 12F8041C 		ldrb	r1, [r2, #-4]	@ zero_extendqisi2
 121 0066 A1F16102 		sub	r2, r1, #97
 122 006a D2B2     		uxtb	r2, r2
 123 006c 052A     		cmp	r2, #5
 124 006e F3D8     		bhi	.L7
 335:Src/gps.c     **** 		{
 336:Src/gps.c     **** 			res_char[j] = (char)((int)res_char[j] + offset_maiusc);
 125              		.loc 1 336 0
 126 0070 2039     		subs	r1, r1, #32
 127 0072 02AA     		add	r2, sp, #8
 128 0074 1A44     		add	r2, r2, r3
 129 0076 02F8041C 		strb	r1, [r2, #-4]
 130 007a EDE7     		b	.L7
 131              	.L13:
 132              	.LBE2:
 337:Src/gps.c     **** 		}
 338:Src/gps.c     **** 	}
 339:Src/gps.c     **** 	if (res_char[0] == check[0] && res_char[1] == check[1])
 133              		.loc 1 339 0
 134 007c 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 135              	.LVL12:
 136 0080 9D42     		cmp	r5, r3
 137 0082 02D0     		beq	.L14
 340:Src/gps.c     **** 	{
 341:Src/gps.c     **** 		return 1; //checksum is correct
 342:Src/gps.c     **** 	}
 343:Src/gps.c     **** 	else
 344:Src/gps.c     **** 	{
 345:Src/gps.c     **** 		return 0; //checksum failed
 138              		.loc 1 345 0
 139 0084 0020     		movs	r0, #0
 140              	.L1:
 346:Src/gps.c     **** 	}
 347:Src/gps.c     **** }...
 141              		.loc 1 347 0
 142 0086 02B0     		add	sp, sp, #8
 143              	.LCFI2:
 144              		.cfi_remember_state
 145              		.cfi_def_cfa_offset 16
 146              		@ sp needed
 147 0088 70BD     		pop	{r4, r5, r6, pc}
 148              	.LVL13:
 149              	.L14:
 150              	.LCFI3:
 151              		.cfi_restore_state
 339:Src/gps.c     **** 	if (res_char[0] == check[0] && res_char[1] == check[1])
 152              		.loc 1 339 0 discriminator 1
 153 008a 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 154 008e 9E42     		cmp	r6, r3
 155 0090 01D0     		beq	.L11
 345:Src/gps.c     **** 		return 0; //checksum failed
 156              		.loc 1 345 0
 157 0092 0020     		movs	r0, #0
 158 0094 F7E7     		b	.L1
 159              	.L11:
 341:Src/gps.c     **** 		return 1; //checksum is correct
ARM GAS  /tmp/ccePSTld.s 			page 10


 160              		.loc 1 341 0
 161 0096 0120     		movs	r0, #1
 162 0098 F5E7     		b	.L1
 163              	.L16:
 164 009a 00BF     		.align	2
 165              	.L15:
 166 009c 00000000 		.word	.LC0
 167 00a0 00000000 		.word	huart2
 168              		.cfi_endproc
 169              	.LFE133:
 171              		.section	.text.gps_init,"ax",%progbits
 172              		.align	1
 173              		.global	gps_init
 174              		.syntax unified
 175              		.thumb
 176              		.thumb_func
 177              		.fpu fpv4-sp-d16
 179              	gps_init:
 180              	.LFB131:
  17:Src/gps.c     **** { //initialization of GPS
 181              		.loc 1 17 0
 182              		.cfi_startproc
 183              		@ args = 0, pretend = 0, frame = 0
 184              		@ frame_needed = 0, uses_anonymous_args = 0
 185              	.LVL14:
 186 0000 38B5     		push	{r3, r4, r5, lr}
 187              	.LCFI4:
 188              		.cfi_def_cfa_offset 16
 189              		.cfi_offset 3, -16
 190              		.cfi_offset 4, -12
 191              		.cfi_offset 5, -8
 192              		.cfi_offset 14, -4
 193 0002 0546     		mov	r5, r0
 194 0004 0C46     		mov	r4, r1
  20:Src/gps.c     **** 	huart->Init.BaudRate = 9600;
 195              		.loc 1 20 0
 196 0006 4FF41653 		mov	r3, #9600
 197 000a 4360     		str	r3, [r0, #4]
  21:Src/gps.c     ****     if (HAL_UART_DeInit(huart) != HAL_OK)
 198              		.loc 1 21 0
 199 000c FFF7FEFF 		bl	HAL_UART_DeInit
 200              	.LVL15:
 201 0010 0028     		cmp	r0, #0
 202 0012 6BD1     		bne	.L22
 203              	.L18:
  25:Src/gps.c     **** 	if (HAL_UART_Init(huart) != HAL_OK)
 204              		.loc 1 25 0
 205 0014 2846     		mov	r0, r5
 206 0016 FFF7FEFF 		bl	HAL_UART_Init
 207              	.LVL16:
 208 001a 0028     		cmp	r0, #0
 209 001c 6DD1     		bne	.L23
 210              	.L19:
  29:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_BAUD_115200, strlen(PMTK_SET_BAUD_115200), 200);
 211              		.loc 1 29 0
 212 001e C823     		movs	r3, #200
 213 0020 1422     		movs	r2, #20
ARM GAS  /tmp/ccePSTld.s 			page 11


 214 0022 3D49     		ldr	r1, .L25
 215 0024 2846     		mov	r0, r5
 216 0026 FFF7FEFF 		bl	HAL_UART_Transmit
 217              	.LVL17:
  30:Src/gps.c     **** 	HAL_Delay(500);
 218              		.loc 1 30 0
 219 002a 4FF4FA70 		mov	r0, #500
 220 002e FFF7FEFF 		bl	HAL_Delay
 221              	.LVL18:
  40:Src/gps.c     ****     huart->Init.BaudRate = 115200;
 222              		.loc 1 40 0
 223 0032 4FF4E133 		mov	r3, #115200
 224 0036 6B60     		str	r3, [r5, #4]
  41:Src/gps.c     **** 	if (HAL_UART_Init(huart) != HAL_OK)
 225              		.loc 1 41 0
 226 0038 2846     		mov	r0, r5
 227 003a FFF7FEFF 		bl	HAL_UART_Init
 228              	.LVL19:
 229 003e 0028     		cmp	r0, #0
 230 0040 62D1     		bne	.L24
 231              	.L20:
  45:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_BAUD_115200, strlen(PMTK_SET_BAUD_115200), 200);
 232              		.loc 1 45 0
 233 0042 C823     		movs	r3, #200
 234 0044 1422     		movs	r2, #20
 235 0046 3449     		ldr	r1, .L25
 236 0048 2846     		mov	r0, r5
 237 004a FFF7FEFF 		bl	HAL_UART_Transmit
 238              	.LVL20:
  46:Src/gps.c     **** 	HAL_Delay(500);
 239              		.loc 1 46 0
 240 004e 4FF4FA70 		mov	r0, #500
 241 0052 FFF7FEFF 		bl	HAL_Delay
 242              	.LVL21:
  47:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_NMEA_UPDATE_10HZ, strlen(PMTK_SET_NMEA_UPDATE_10HZ), 
 243              		.loc 1 47 0
 244 0056 C823     		movs	r3, #200
 245 0058 1122     		movs	r2, #17
 246 005a 3049     		ldr	r1, .L25+4
 247 005c 2846     		mov	r0, r5
 248 005e FFF7FEFF 		bl	HAL_UART_Transmit
 249              	.LVL22:
  48:Src/gps.c     **** 	HAL_Delay(500);
 250              		.loc 1 48 0
 251 0062 4FF4FA70 		mov	r0, #500
 252 0066 FFF7FEFF 		bl	HAL_Delay
 253              	.LVL23:
  49:Src/gps.c     **** 	HAL_UART_Transmit(huart, (uint8_t *)PMTK_SET_NMEA_OUTPUT_GGAVTG, strlen(PMTK_SET_NMEA_OUTPUT_GGAVT
 254              		.loc 1 49 0
 255 006a C823     		movs	r3, #200
 256 006c 3322     		movs	r2, #51
 257 006e 2C49     		ldr	r1, .L25+8
 258 0070 2846     		mov	r0, r5
 259 0072 FFF7FEFF 		bl	HAL_UART_Transmit
 260              	.LVL24:
  50:Src/gps.c     **** 	HAL_Delay(500);
 261              		.loc 1 50 0
ARM GAS  /tmp/ccePSTld.s 			page 12


 262 0076 4FF4FA70 		mov	r0, #500
 263 007a FFF7FEFF 		bl	HAL_Delay
 264              	.LVL25:
  51:Src/gps.c     **** 	strcpy(gps->speed, "000.00");
 265              		.loc 1 51 0
 266 007e 294B     		ldr	r3, .L25+12
 267 0080 1868     		ldr	r0, [r3]
 268 0082 6060     		str	r0, [r4, #4]	@ unaligned
 269 0084 9988     		ldrh	r1, [r3, #4]	@ unaligned
 270 0086 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 271 0088 2181     		strh	r1, [r4, #8]	@ unaligned
 272 008a A372     		strb	r3, [r4, #10]
  52:Src/gps.c     **** 	strcpy(gps->latitude, "0000.0000");
 273              		.loc 1 52 0
 274 008c 264B     		ldr	r3, .L25+16
 275 008e 03CB     		ldmia	r3!, {r0, r1}
 276 0090 2061     		str	r0, [r4, #16]	@ unaligned
 277 0092 6161     		str	r1, [r4, #20]	@ unaligned
 278 0094 1B88     		ldrh	r3, [r3]	@ unaligned
 279 0096 2383     		strh	r3, [r4, #24]	@ unaligned
  53:Src/gps.c     **** 	strcpy(gps->latitude_o, "N");
 280              		.loc 1 53 0
 281 0098 244B     		ldr	r3, .L25+20
 282 009a 1B88     		ldrh	r3, [r3]	@ unaligned
 283 009c 2384     		strh	r3, [r4, #32]	@ unaligned
  54:Src/gps.c     **** 	strcpy(gps->longitude, "00000.0000");
 284              		.loc 1 54 0
 285 009e 244B     		ldr	r3, .L25+24
 286 00a0 03CB     		ldmia	r3!, {r0, r1}
 287 00a2 2063     		str	r0, [r4, #48]	@ unaligned
 288 00a4 6163     		str	r1, [r4, #52]	@ unaligned
 289 00a6 1988     		ldrh	r1, [r3]	@ unaligned
 290 00a8 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 291 00aa 2187     		strh	r1, [r4, #56]	@ unaligned
 292 00ac 84F83A30 		strb	r3, [r4, #58]
  55:Src/gps.c     **** 	strcpy(gps->longitude_o, "W");
 293              		.loc 1 55 0
 294 00b0 204B     		ldr	r3, .L25+28
 295 00b2 1B88     		ldrh	r3, [r3]	@ unaligned
 296 00b4 A4F84030 		strh	r3, [r4, #64]	@ unaligned
  56:Src/gps.c     **** 	strcpy(gps->altitude, "0000.0");
 297              		.loc 1 56 0
 298 00b8 1F4B     		ldr	r3, .L25+32
 299 00ba 1868     		ldr	r0, [r3]
 300 00bc 2065     		str	r0, [r4, #80]	@ unaligned
 301 00be 9988     		ldrh	r1, [r3, #4]	@ unaligned
 302 00c0 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 303 00c2 A4F85410 		strh	r1, [r4, #84]	@ unaligned
 304 00c6 84F85630 		strb	r3, [r4, #86]
  57:Src/gps.c     **** 	strcpy(gps->hour, "00");
 305              		.loc 1 57 0
 306 00ca 1C4B     		ldr	r3, .L25+36
 307 00cc 1A88     		ldrh	r2, [r3]	@ unaligned
 308 00ce 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 309 00d0 A4F86820 		strh	r2, [r4, #104]	@ unaligned
 310 00d4 84F86A30 		strb	r3, [r4, #106]
  58:Src/gps.c     ****     strcpy(gps->min, "00");
ARM GAS  /tmp/ccePSTld.s 			page 13


 311              		.loc 1 58 0
 312 00d8 A4F86B20 		strh	r2, [r4, #107]	@ unaligned
 313 00dc 84F86D30 		strb	r3, [r4, #109]
  59:Src/gps.c     ****     strcpy(gps->sec, "00");
 314              		.loc 1 59 0
 315 00e0 A4F86E20 		strh	r2, [r4, #110]	@ unaligned
 316 00e4 84F87030 		strb	r3, [r4, #112]
  63:Src/gps.c     **** }
 317              		.loc 1 63 0
 318 00e8 0120     		movs	r0, #1
 319 00ea 38BD     		pop	{r3, r4, r5, pc}
 320              	.LVL26:
 321              	.L22:
  23:Src/gps.c     ****         HAL_UART_Transmit(&huart2,(uint8_t*)"ERRORE 3\r\n",6,10);
 322              		.loc 1 23 0
 323 00ec 0A23     		movs	r3, #10
 324 00ee 0622     		movs	r2, #6
 325 00f0 1349     		ldr	r1, .L25+40
 326 00f2 1448     		ldr	r0, .L25+44
 327 00f4 FFF7FEFF 		bl	HAL_UART_Transmit
 328              	.LVL27:
 329 00f8 8CE7     		b	.L18
 330              	.L23:
  27:Src/gps.c     ****         HAL_UART_Transmit(&huart2,(uint8_t*)"ERRORE 4\r\n",6,10);
 331              		.loc 1 27 0
 332 00fa 0A23     		movs	r3, #10
 333 00fc 0622     		movs	r2, #6
 334 00fe 1249     		ldr	r1, .L25+48
 335 0100 1048     		ldr	r0, .L25+44
 336 0102 FFF7FEFF 		bl	HAL_UART_Transmit
 337              	.LVL28:
 338 0106 8AE7     		b	.L19
 339              	.L24:
  43:Src/gps.c     ****         HAL_UART_Transmit(&huart2,(uint8_t*)"ERRORE 6\r\n",6,10);
 340              		.loc 1 43 0
 341 0108 0A23     		movs	r3, #10
 342 010a 0622     		movs	r2, #6
 343 010c 0F49     		ldr	r1, .L25+52
 344 010e 0D48     		ldr	r0, .L25+44
 345 0110 FFF7FEFF 		bl	HAL_UART_Transmit
 346              	.LVL29:
 347 0114 95E7     		b	.L20
 348              	.L26:
 349 0116 00BF     		.align	2
 350              	.L25:
 351 0118 18000000 		.word	.LC3
 352 011c 3C000000 		.word	.LC5
 353 0120 50000000 		.word	.LC6
 354 0124 84000000 		.word	.LC7
 355 0128 8C000000 		.word	.LC8
 356 012c 98000000 		.word	.LC9
 357 0130 9C000000 		.word	.LC10
 358 0134 A8000000 		.word	.LC11
 359 0138 AC000000 		.word	.LC12
 360 013c B4000000 		.word	.LC13
 361 0140 00000000 		.word	.LC1
 362 0144 00000000 		.word	huart2
ARM GAS  /tmp/ccePSTld.s 			page 14


 363 0148 0C000000 		.word	.LC2
 364 014c 30000000 		.word	.LC4
 365              		.cfi_endproc
 366              	.LFE131:
 368              		.global	__aeabi_dmul
 369              		.global	__aeabi_d2iz
 370              		.section	.text.gps_read,"ax",%progbits
 371              		.align	1
 372              		.global	gps_read
 373              		.syntax unified
 374              		.thumb
 375              		.thumb_func
 376              		.fpu fpv4-sp-d16
 378              	gps_read:
 379              	.LFB132:
  66:Src/gps.c     **** {
 380              		.loc 1 66 0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 256
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              	.LVL30:
 385 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 386              	.LCFI5:
 387              		.cfi_def_cfa_offset 24
 388              		.cfi_offset 4, -24
 389              		.cfi_offset 5, -20
 390              		.cfi_offset 6, -16
 391              		.cfi_offset 7, -12
 392              		.cfi_offset 8, -8
 393              		.cfi_offset 14, -4
 394 0004 C4B0     		sub	sp, sp, #272
 395              	.LCFI6:
 396              		.cfi_def_cfa_offset 296
 397              	.LVL31:
 108:Src/gps.c     ****     if(msg_arrived > 0){
 398              		.loc 1 108 0
 399 0006 B44B     		ldr	r3, .L84
 400 0008 1C68     		ldr	r4, [r3]
 401 000a 002C     		cmp	r4, #0
 402 000c 01DD     		ble	.L66
 403 000e 0023     		movs	r3, #0
 404 0010 08E0     		b	.L28
 405              	.L66:
  68:Src/gps.c     **** 	int ret = 0; //return--> 0=error,1=ok
 406              		.loc 1 68 0
 407 0012 0026     		movs	r6, #0
 408 0014 0CE2     		b	.L27
 409              	.LVL32:
 410              	.L30:
 411              	.LBB3:
 110:Src/gps.c     ****             buffer_gps_s[i] = buffer_gps[i];
 412              		.loc 1 110 0 discriminator 3
 413 0016 B14A     		ldr	r2, .L84+4
 414 0018 D05C     		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 415 001a 44AA     		add	r2, sp, #272
 416 001c 1A44     		add	r2, r2, r3
 417 001e 02F8340C 		strb	r0, [r2, #-52]
ARM GAS  /tmp/ccePSTld.s 			page 15


 109:Src/gps.c     ****         for(int i = 0; i < msg_arrived; i++){
 418              		.loc 1 109 0 discriminator 3
 419 0022 0133     		adds	r3, r3, #1
 420              	.LVL33:
 421              	.L28:
 109:Src/gps.c     ****         for(int i = 0; i < msg_arrived; i++){
 422              		.loc 1 109 0 is_stmt 0 discriminator 1
 423 0024 A342     		cmp	r3, r4
 424 0026 F6DB     		blt	.L30
 425 0028 0D46     		mov	r5, r1
 426 002a 0024     		movs	r4, #0
 427 002c 2646     		mov	r6, r4
 428 002e 0CE0     		b	.L31
 429              	.LVL34:
 430              	.L69:
 431              	.LBE3:
 432              	.LBB4:
 115:Src/gps.c     ****             if ((start_string_gps == 1) && (data_string_gps != '$'))
 433              		.loc 1 115 0 is_stmt 1 discriminator 1
 434 0030 242B     		cmp	r3, #36
 435 0032 19D0     		beq	.L32
 117:Src/gps.c     ****                 string_gps[cont_string] = data_string_gps; //save the data into the array
 436              		.loc 1 117 0
 437 0034 AA48     		ldr	r0, .L84+8
 438 0036 0268     		ldr	r2, [r0]
 439 0038 AA49     		ldr	r1, .L84+12
 440 003a 8B54     		strb	r3, [r1, r2]
 118:Src/gps.c     ****                 cont_string++;
 441              		.loc 1 118 0
 442 003c 571C     		adds	r7, r2, #1
 443 003e 0760     		str	r7, [r0]
 119:Src/gps.c     ****                 if (string_gps[cont_string - 2] == '\r' && string_gps[cont_string - 1] == '\n')
 444              		.loc 1 119 0
 445 0040 013A     		subs	r2, r2, #1
 446 0042 895C     		ldrb	r1, [r1, r2]	@ zero_extendqisi2
 447 0044 0D29     		cmp	r1, #13
 448 0046 18D0     		beq	.L67
 449              	.L33:
 113:Src/gps.c     ****         for(int j = 0; j < msg_arrived; j++){
 450              		.loc 1 113 0 discriminator 2
 451 0048 0134     		adds	r4, r4, #1
 452              	.LVL35:
 453              	.L31:
 113:Src/gps.c     ****         for(int j = 0; j < msg_arrived; j++){
 454              		.loc 1 113 0 is_stmt 0 discriminator 1
 455 004a A34B     		ldr	r3, .L84
 456 004c 1B68     		ldr	r3, [r3]
 457 004e 9C42     		cmp	r4, r3
 458 0050 80F2EB81 		bge	.L68
 114:Src/gps.c     ****             data_string_gps = buffer_gps_s[j];
 459              		.loc 1 114 0 is_stmt 1
 460 0054 44AB     		add	r3, sp, #272
 461 0056 2344     		add	r3, r3, r4
 462 0058 13F8343C 		ldrb	r3, [r3, #-52]	@ zero_extendqisi2
 463 005c A24A     		ldr	r2, .L84+16
 464 005e 1370     		strb	r3, [r2]
 115:Src/gps.c     ****             if ((start_string_gps == 1) && (data_string_gps != '$'))
ARM GAS  /tmp/ccePSTld.s 			page 16


 465              		.loc 1 115 0
 466 0060 A24A     		ldr	r2, .L84+20
 467 0062 1268     		ldr	r2, [r2]
 468 0064 012A     		cmp	r2, #1
 469 0066 E3D0     		beq	.L69
 470              	.L32:
 296:Src/gps.c     ****                 if (data_string_gps == '$')
 471              		.loc 1 296 0
 472 0068 242B     		cmp	r3, #36
 473 006a EDD1     		bne	.L33
 298:Src/gps.c     ****                     start_string_gps = 1; //new string started
 474              		.loc 1 298 0
 475 006c 0122     		movs	r2, #1
 476 006e 9F4B     		ldr	r3, .L84+20
 477 0070 1A60     		str	r2, [r3]
 299:Src/gps.c     ****                     cont_string = 0;	  //set the counter to 1
 478              		.loc 1 299 0
 479 0072 0022     		movs	r2, #0
 480 0074 9A4B     		ldr	r3, .L84+8
 481 0076 1A60     		str	r2, [r3]
 482 0078 E6E7     		b	.L33
 483              	.L67:
 119:Src/gps.c     ****                 if (string_gps[cont_string - 2] == '\r' && string_gps[cont_string - 1] == '\n')
 484              		.loc 1 119 0 discriminator 1
 485 007a 0A2B     		cmp	r3, #10
 486 007c E4D1     		bne	.L33
 487              	.LBB5:
 121:Src/gps.c     ****                     cont_string = cont_string -2;
 488              		.loc 1 121 0
 489 007e 0260     		str	r2, [r0]
 122:Src/gps.c     ****                     string_gps[cont_string] = '\0'; // '\0'=end of the string
 490              		.loc 1 122 0
 491 0080 984F     		ldr	r7, .L84+12
 492 0082 0023     		movs	r3, #0
 493 0084 BB54     		strb	r3, [r7, r2]
 123:Src/gps.c     ****                     start_string_gps = 0;	
 494              		.loc 1 123 0
 495 0086 994A     		ldr	r2, .L84+20
 496 0088 1360     		str	r3, [r2]
 126:Src/gps.c     ****                         sprintf(txt, "%s\r\n", string_gps);
 497              		.loc 1 126 0
 498 008a 3A46     		mov	r2, r7
 499 008c 9849     		ldr	r1, .L84+24
 500 008e 05A8     		add	r0, sp, #20
 501 0090 FFF7FEFF 		bl	sprintf
 502              	.LVL36:
 127:Src/gps.c     ****                         HAL_UART_Transmit(&huart2, (uint8_t*)txt, strlen(txt), 10);
 503              		.loc 1 127 0
 504 0094 05A8     		add	r0, sp, #20
 505 0096 FFF7FEFF 		bl	strlen
 506              	.LVL37:
 507 009a 0A23     		movs	r3, #10
 508 009c 82B2     		uxth	r2, r0
 509 009e 05A9     		add	r1, sp, #20
 510 00a0 9448     		ldr	r0, .L84+28
 511 00a2 FFF7FEFF 		bl	HAL_UART_Transmit
 512              	.LVL38:
ARM GAS  /tmp/ccePSTld.s 			page 17


 128:Src/gps.c     ****                     if (string_gps[2] == 'G' && string_gps[3] == 'G' && string_gps[4] == 'A')
 513              		.loc 1 128 0
 514 00a6 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 515 00a8 472B     		cmp	r3, #71
 516 00aa 08D0     		beq	.L70
 517              	.L34:
 230:Src/gps.c     ****                     else if (string_gps[2] == 'V' && string_gps[3] == 'T' && string_gps[4] == 'G')
 518              		.loc 1 230 0
 519 00ac 562B     		cmp	r3, #86
 520 00ae 00F03181 		beq	.L71
 521              	.LVL39:
 522              	.L50:
 287:Src/gps.c     ****                     strcpy(string_gps, "");
 523              		.loc 1 287 0 discriminator 2
 524 00b2 0023     		movs	r3, #0
 525 00b4 8B4A     		ldr	r2, .L84+12
 526 00b6 1370     		strb	r3, [r2]
 288:Src/gps.c     ****                     cont_string = 0;
 527              		.loc 1 288 0 discriminator 2
 528 00b8 894A     		ldr	r2, .L84+8
 529 00ba 1360     		str	r3, [r2]
 530 00bc C4E7     		b	.L33
 531              	.L70:
 128:Src/gps.c     ****                     if (string_gps[2] == 'G' && string_gps[3] == 'G' && string_gps[4] == 'A')
 532              		.loc 1 128 0 discriminator 1
 533 00be FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 534 00c0 472A     		cmp	r2, #71
 535 00c2 F3D1     		bne	.L34
 128:Src/gps.c     ****                     if (string_gps[2] == 'G' && string_gps[3] == 'G' && string_gps[4] == 'A')
 536              		.loc 1 128 0 is_stmt 0 discriminator 2
 537 00c4 3A79     		ldrb	r2, [r7, #4]	@ zero_extendqisi2
 538 00c6 412A     		cmp	r2, #65
 539 00c8 F0D1     		bne	.L34
 133:Src/gps.c     ****                         if (checksum(string_gps, cont_string) == 1)
 540              		.loc 1 133 0 is_stmt 1
 541 00ca 854B     		ldr	r3, .L84+8
 542 00cc 1968     		ldr	r1, [r3]
 543 00ce 3846     		mov	r0, r7
 544 00d0 FFF7FEFF 		bl	checksum
 545              	.LVL40:
 546 00d4 0646     		mov	r6, r0
 547              	.LVL41:
 548 00d6 0128     		cmp	r0, #1
 549 00d8 66D0     		beq	.L72
 550              	.LBB6:
 225:Src/gps.c     ****                             sprintf(txt,"\r\nCHECKSUM FAIL\r\n");
 551              		.loc 1 225 0
 552 00da 1EAE     		add	r6, sp, #120
 553 00dc 864F     		ldr	r7, .L84+32
 554 00de 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 555 00e0 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 556 00e2 3B68     		ldr	r3, [r7]
 557 00e4 3380     		strh	r3, [r6]	@ movhi
 226:Src/gps.c     ****                             HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 558              		.loc 1 226 0
 559 00e6 1EA8     		add	r0, sp, #120
 560 00e8 FFF7FEFF 		bl	strlen
ARM GAS  /tmp/ccePSTld.s 			page 18


 561              	.LVL42:
 562 00ec 0A23     		movs	r3, #10
 563 00ee 82B2     		uxth	r2, r0
 564 00f0 1EA9     		add	r1, sp, #120
 565 00f2 8048     		ldr	r0, .L84+28
 566 00f4 FFF7FEFF 		bl	HAL_UART_Transmit
 567              	.LVL43:
 227:Src/gps.c     ****                             ret = 0; //checksum failed
 568              		.loc 1 227 0
 569 00f8 0026     		movs	r6, #0
 570 00fa DAE7     		b	.L50
 571              	.LVL44:
 572              	.L74:
 573              	.LBE6:
 574              	.LBB7:
 575              	.LBB8:
 139:Src/gps.c     ****                                     cont_comma++;
 576              		.loc 1 139 0
 577 00fc 0132     		adds	r2, r2, #1
 578              	.LVL45:
 579              	.L38:
 136:Src/gps.c     ****                             for (int i = 5; i < 100; i++)
 580              		.loc 1 136 0 discriminator 2
 581 00fe 0137     		adds	r7, r7, #1
 582              	.LVL46:
 583              	.L35:
 136:Src/gps.c     ****                             for (int i = 5; i < 100; i++)
 584              		.loc 1 136 0 is_stmt 0 discriminator 1
 585 0100 632F     		cmp	r7, #99
 586 0102 58DC     		bgt	.L73
 138:Src/gps.c     ****                                 if (string_gps[i] == ',')
 587              		.loc 1 138 0 is_stmt 1
 588 0104 7749     		ldr	r1, .L84+12
 589 0106 C95D     		ldrb	r1, [r1, r7]	@ zero_extendqisi2
 590 0108 2C29     		cmp	r1, #44
 591 010a F7D0     		beq	.L74
 142:Src/gps.c     ****                                     if (cont_comma == 1)
 592              		.loc 1 142 0
 593 010c 012A     		cmp	r2, #1
 594 010e 07D0     		beq	.L75
 156:Src/gps.c     ****                                     else if (cont_comma == 2)
 595              		.loc 1 156 0
 596 0110 022A     		cmp	r2, #2
 597 0112 24D1     		bne	.L42
 159:Src/gps.c     ****                                         gps->latitude[cont_latitude] = string_gps[i];
 598              		.loc 1 159 0
 599 0114 05EB0E00 		add	r0, r5, lr
 600 0118 0174     		strb	r1, [r0, #16]
 160:Src/gps.c     ****                                         cont_latitude++;
 601              		.loc 1 160 0
 602 011a 0EF1010E 		add	lr, lr, #1
 603              	.LVL47:
 604 011e EEE7     		b	.L38
 605              	.L75:
 144:Src/gps.c     ****                                         if(cont_time < 2){
 606              		.loc 1 144 0
 607 0120 012B     		cmp	r3, #1
ARM GAS  /tmp/ccePSTld.s 			page 19


 608 0122 0BDD     		ble	.L76
 147:Src/gps.c     ****                                         }else if(cont_time < 4){
 609              		.loc 1 147 0
 610 0124 032B     		cmp	r3, #3
 611 0126 0EDC     		bgt	.L41
 148:Src/gps.c     ****                                             gps->min[cont_time % 2] = string_gps[i];
 612              		.loc 1 148 0
 613 0128 002B     		cmp	r3, #0
 614 012a 03F00100 		and	r0, r3, #1
 615 012e B8BF     		it	lt
 616 0130 4042     		rsblt	r0, r0, #0
 617 0132 2844     		add	r0, r0, r5
 618 0134 80F86B10 		strb	r1, [r0, #107]
 149:Src/gps.c     ****                                             cont_time++;
 619              		.loc 1 149 0
 620 0138 0133     		adds	r3, r3, #1
 621              	.LVL48:
 622 013a E0E7     		b	.L38
 623              	.L76:
 145:Src/gps.c     ****                                             gps->hour[cont_time] = string_gps[i];
 624              		.loc 1 145 0
 625 013c E818     		adds	r0, r5, r3
 626 013e 80F86810 		strb	r1, [r0, #104]
 146:Src/gps.c     ****                                             cont_time++;
 627              		.loc 1 146 0
 628 0142 0133     		adds	r3, r3, #1
 629              	.LVL49:
 630 0144 DBE7     		b	.L38
 631              	.L41:
 150:Src/gps.c     ****                                         }else if(cont_time <6){
 632              		.loc 1 150 0
 633 0146 052B     		cmp	r3, #5
 634 0148 D9DC     		bgt	.L38
 151:Src/gps.c     ****                                             gps->sec[cont_time % 2] = string_gps[i];
 635              		.loc 1 151 0
 636 014a 002B     		cmp	r3, #0
 637 014c 03F00100 		and	r0, r3, #1
 638 0150 B8BF     		it	lt
 639 0152 4042     		rsblt	r0, r0, #0
 640 0154 2844     		add	r0, r0, r5
 641 0156 80F86E10 		strb	r1, [r0, #110]
 152:Src/gps.c     ****                                             cont_time++;
 642              		.loc 1 152 0
 643 015a 0133     		adds	r3, r3, #1
 644              	.LVL50:
 645 015c CFE7     		b	.L38
 646              	.L42:
 162:Src/gps.c     ****                                     else if (cont_comma == 3)
 647              		.loc 1 162 0
 648 015e 032A     		cmp	r2, #3
 649 0160 02D1     		bne	.L43
 164:Src/gps.c     ****                                         gps->latitude_o[0] = string_gps[i];
 650              		.loc 1 164 0
 651 0162 85F82010 		strb	r1, [r5, #32]
 652 0166 CAE7     		b	.L38
 653              	.L43:
 166:Src/gps.c     ****                                     else if (cont_comma == 4)
ARM GAS  /tmp/ccePSTld.s 			page 20


 654              		.loc 1 166 0
 655 0168 042A     		cmp	r2, #4
 656 016a 0CD0     		beq	.L77
 171:Src/gps.c     ****                                     else if (cont_comma == 5)
 657              		.loc 1 171 0
 658 016c 052A     		cmp	r2, #5
 659 016e 11D0     		beq	.L78
 175:Src/gps.c     ****                                     else if (cont_comma == 6)
 660              		.loc 1 175 0
 661 0170 062A     		cmp	r2, #6
 662 0172 12D0     		beq	.L79
 179:Src/gps.c     ****                                     else if (cont_comma == 9)
 663              		.loc 1 179 0
 664 0174 092A     		cmp	r2, #9
 665 0176 13D1     		bne	.L47
 181:Src/gps.c     ****                                         gps->altitude[cont_altitude] = string_gps[i];
 666              		.loc 1 181 0
 667 0178 05EB0800 		add	r0, r5, r8
 668 017c 80F85010 		strb	r1, [r0, #80]
 182:Src/gps.c     ****                                         cont_altitude++;
 669              		.loc 1 182 0
 670 0180 08F10108 		add	r8, r8, #1
 671              	.LVL51:
 672 0184 BBE7     		b	.L38
 673              	.L77:
 168:Src/gps.c     ****                                         gps->longitude[cont_longitude] = string_gps[i];
 674              		.loc 1 168 0
 675 0186 05EB0C00 		add	r0, r5, ip
 676 018a 80F83010 		strb	r1, [r0, #48]
 169:Src/gps.c     ****                                         cont_longitude++;
 677              		.loc 1 169 0
 678 018e 0CF1010C 		add	ip, ip, #1
 679              	.LVL52:
 680 0192 B4E7     		b	.L38
 681              	.L78:
 173:Src/gps.c     ****                                         gps->longitude_o[0] = string_gps[i];
 682              		.loc 1 173 0
 683 0194 85F84010 		strb	r1, [r5, #64]
 684 0198 B1E7     		b	.L38
 685              	.L79:
 177:Src/gps.c     ****                                         gps->fix_status = string_gps[i];
 686              		.loc 1 177 0
 687 019a 85F87110 		strb	r1, [r5, #113]
 688 019e AEE7     		b	.L38
 689              	.L47:
 184:Src/gps.c     ****                                     else if (cont_comma == 10)
 690              		.loc 1 184 0
 691 01a0 0A2A     		cmp	r2, #10
 692 01a2 ACD1     		bne	.L38
 186:Src/gps.c     ****                                         i = 100; //end the cicle
 693              		.loc 1 186 0
 694 01a4 6427     		movs	r7, #100
 695              	.LVL53:
 696 01a6 AAE7     		b	.L38
 697              	.LVL54:
 698              	.L72:
 699              	.LBE8:
ARM GAS  /tmp/ccePSTld.s 			page 21


 700              	.LBE7:
 701 01a8 0527     		movs	r7, #5
 702 01aa 0023     		movs	r3, #0
 703 01ac 9846     		mov	r8, r3
 704 01ae 9C46     		mov	ip, r3
 705 01b0 9E46     		mov	lr, r3
 706 01b2 1A46     		mov	r2, r3
 707 01b4 A4E7     		b	.L35
 708              	.LVL55:
 709              	.L73:
 710              	.LBB11:
 192:Src/gps.c     ****                             if (gps->fix_status == '0')
 711              		.loc 1 192 0
 712 01b6 95F87130 		ldrb	r3, [r5, #113]	@ zero_extendqisi2
 713              	.LVL56:
 714 01ba 302B     		cmp	r3, #48
 715 01bc 18D1     		bne	.L49
 716              	.LBB9:
 195:Src/gps.c     ****                                 sprintf(txt,"\r\nNO CONNECTION\r\n");
 717              		.loc 1 195 0
 718 01be 1EAF     		add	r7, sp, #120
 719              	.LVL57:
 720 01c0 DFF84CE1 		ldr	lr, .L84+56
 721              	.LVL58:
 722 01c4 BEE80F00 		ldmia	lr!, {r0, r1, r2, r3}
 723              	.LVL59:
 724 01c8 0FC7     		stmia	r7!, {r0, r1, r2, r3}
 725 01ca DEF80030 		ldr	r3, [lr]
 726 01ce 3B80     		strh	r3, [r7]	@ movhi
 196:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 727              		.loc 1 196 0
 728 01d0 1EA8     		add	r0, sp, #120
 729 01d2 FFF7FEFF 		bl	strlen
 730              	.LVL60:
 731 01d6 0A23     		movs	r3, #10
 732 01d8 82B2     		uxth	r2, r0
 733 01da 1EA9     		add	r1, sp, #120
 734 01dc 4548     		ldr	r0, .L84+28
 735 01de FFF7FEFF 		bl	HAL_UART_Transmit
 736              	.LVL61:
 197:Src/gps.c     ****                                 gps->latitude_i_h = 0;
 737              		.loc 1 197 0
 738 01e2 0023     		movs	r3, #0
 739 01e4 AB62     		str	r3, [r5, #40]
 198:Src/gps.c     ****                                 gps->latitude_i_l = 0;
 740              		.loc 1 198 0
 741 01e6 EB62     		str	r3, [r5, #44]
 199:Src/gps.c     ****                                 gps->longitude_i_h = 0;
 742              		.loc 1 199 0
 743 01e8 AB64     		str	r3, [r5, #72]
 200:Src/gps.c     ****                                 gps->longitude_i_l = 0;
 744              		.loc 1 200 0
 745 01ea EB64     		str	r3, [r5, #76]
 201:Src/gps.c     ****                                 gps->altitude_i = 0;
 746              		.loc 1 201 0
 747 01ec AB65     		str	r3, [r5, #88]
 748              	.LBE9:
ARM GAS  /tmp/ccePSTld.s 			page 22


 749 01ee 60E7     		b	.L50
 750              	.LVL62:
 751              	.L49:
 752              	.LBB10:
 206:Src/gps.c     ****                                 gps->latitude_i = (long int)(atof(gps->latitude) * 100);
 753              		.loc 1 206 0
 754 01f0 05F11000 		add	r0, r5, #16
 755 01f4 FFF7FEFF 		bl	atof
 756              	.LVL63:
 757 01f8 0022     		movs	r2, #0
 758 01fa 404B     		ldr	r3, .L84+36
 759 01fc 51EC100B 		vmov	r0, r1, d0
 760 0200 FFF7FEFF 		bl	__aeabi_dmul
 761              	.LVL64:
 762 0204 FFF7FEFF 		bl	__aeabi_d2iz
 763              	.LVL65:
 764 0208 0246     		mov	r2, r0
 765 020a 6862     		str	r0, [r5, #36]
 207:Src/gps.c     ****                                 sprintf(txt,"latitude %ld %c", gps->latitude_i, gps->latitude_o[0])
 766              		.loc 1 207 0
 767 020c 95F82030 		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 768 0210 3B49     		ldr	r1, .L84+40
 769 0212 1EA8     		add	r0, sp, #120
 770 0214 FFF7FEFF 		bl	sprintf
 771              	.LVL66:
 208:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 772              		.loc 1 208 0
 773 0218 1EA8     		add	r0, sp, #120
 774 021a FFF7FEFF 		bl	strlen
 775              	.LVL67:
 776 021e 354F     		ldr	r7, .L84+28
 777              	.LVL68:
 778 0220 0A23     		movs	r3, #10
 779 0222 82B2     		uxth	r2, r0
 780 0224 1EA9     		add	r1, sp, #120
 781 0226 3846     		mov	r0, r7
 782 0228 FFF7FEFF 		bl	HAL_UART_Transmit
 783              	.LVL69:
 209:Src/gps.c     ****                                 gps->longitude_i = (long int)(atof(gps->longitude) * 100);
 784              		.loc 1 209 0
 785 022c 05F13000 		add	r0, r5, #48
 786 0230 FFF7FEFF 		bl	atof
 787              	.LVL70:
 788 0234 0022     		movs	r2, #0
 789 0236 314B     		ldr	r3, .L84+36
 790 0238 51EC100B 		vmov	r0, r1, d0
 791 023c FFF7FEFF 		bl	__aeabi_dmul
 792              	.LVL71:
 793 0240 FFF7FEFF 		bl	__aeabi_d2iz
 794              	.LVL72:
 795 0244 0246     		mov	r2, r0
 796 0246 6864     		str	r0, [r5, #68]
 210:Src/gps.c     ****                                 sprintf(txt,"longitude %ld %c",gps->longitude_i, gps->longitude_o[0
 797              		.loc 1 210 0
 798 0248 95F84030 		ldrb	r3, [r5, #64]	@ zero_extendqisi2
 799 024c 2D49     		ldr	r1, .L84+44
 800 024e 1EA8     		add	r0, sp, #120
ARM GAS  /tmp/ccePSTld.s 			page 23


 801 0250 FFF7FEFF 		bl	sprintf
 802              	.LVL73:
 211:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 803              		.loc 1 211 0
 804 0254 1EA8     		add	r0, sp, #120
 805 0256 FFF7FEFF 		bl	strlen
 806              	.LVL74:
 807 025a 0A23     		movs	r3, #10
 808 025c 82B2     		uxth	r2, r0
 809 025e 1EA9     		add	r1, sp, #120
 810 0260 3846     		mov	r0, r7
 811 0262 FFF7FEFF 		bl	HAL_UART_Transmit
 812              	.LVL75:
 212:Src/gps.c     ****                                 sprintf(txt,"time %c%c:%c%c:%c%c", gps->hour[0], gps->hour[1], gps-
 813              		.loc 1 212 0
 814 0266 95F86820 		ldrb	r2, [r5, #104]	@ zero_extendqisi2
 815 026a 95F86930 		ldrb	r3, [r5, #105]	@ zero_extendqisi2
 816 026e 95F86B10 		ldrb	r1, [r5, #107]	@ zero_extendqisi2
 817 0272 95F86C00 		ldrb	r0, [r5, #108]	@ zero_extendqisi2
 818 0276 95F86EE0 		ldrb	lr, [r5, #110]	@ zero_extendqisi2
 819 027a 95F86FC0 		ldrb	ip, [r5, #111]	@ zero_extendqisi2
 820 027e CDF80CC0 		str	ip, [sp, #12]
 821 0282 CDF808E0 		str	lr, [sp, #8]
 822 0286 0190     		str	r0, [sp, #4]
 823 0288 0091     		str	r1, [sp]
 824 028a 1F49     		ldr	r1, .L84+48
 825 028c 1EA8     		add	r0, sp, #120
 826 028e FFF7FEFF 		bl	sprintf
 827              	.LVL76:
 213:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 828              		.loc 1 213 0
 829 0292 1EA8     		add	r0, sp, #120
 830 0294 FFF7FEFF 		bl	strlen
 831              	.LVL77:
 832 0298 0A23     		movs	r3, #10
 833 029a 82B2     		uxth	r2, r0
 834 029c 1EA9     		add	r1, sp, #120
 835 029e 3846     		mov	r0, r7
 836 02a0 FFF7FEFF 		bl	HAL_UART_Transmit
 837              	.LVL78:
 214:Src/gps.c     ****                                 gps->altitude_i = (int)(atof(gps->altitude) * 10);
 838              		.loc 1 214 0
 839 02a4 05F15000 		add	r0, r5, #80
 840 02a8 FFF7FEFF 		bl	atof
 841              	.LVL79:
 842 02ac 0022     		movs	r2, #0
 843 02ae 174B     		ldr	r3, .L84+52
 844 02b0 51EC100B 		vmov	r0, r1, d0
 845 02b4 FFF7FEFF 		bl	__aeabi_dmul
 846              	.LVL80:
 847 02b8 FFF7FEFF 		bl	__aeabi_d2iz
 848              	.LVL81:
 849 02bc A865     		str	r0, [r5, #88]
 215:Src/gps.c     ****                                 gps->latitude_i_h = (int)(gps->latitude_i >> 16);
 850              		.loc 1 215 0
 851 02be 6B6A     		ldr	r3, [r5, #36]
 852 02c0 1A14     		asrs	r2, r3, #16
ARM GAS  /tmp/ccePSTld.s 			page 24


 853 02c2 AA62     		str	r2, [r5, #40]
 216:Src/gps.c     ****                                 gps->latitude_i_l = (int)(gps->latitude_i - (gps->latitude_i_h << 1
 854              		.loc 1 216 0
 855 02c4 A3EB0243 		sub	r3, r3, r2, lsl #16
 856 02c8 EB62     		str	r3, [r5, #44]
 217:Src/gps.c     ****                                 gps->longitude_i_h = (int)(gps->longitude_i >> 16);
 857              		.loc 1 217 0
 858 02ca 6B6C     		ldr	r3, [r5, #68]
 859 02cc 1A14     		asrs	r2, r3, #16
 860 02ce AA64     		str	r2, [r5, #72]
 218:Src/gps.c     ****                                 gps->longitude_i_l = (int)(gps->longitude_i - (gps->longitude_i_h <
 861              		.loc 1 218 0
 862 02d0 A3EB0243 		sub	r3, r3, r2, lsl #16
 863 02d4 EB64     		str	r3, [r5, #76]
 864 02d6 ECE6     		b	.L50
 865              	.L85:
 866              		.align	2
 867              	.L84:
 868 02d8 00000000 		.word	msg_arrived
 869 02dc 00000000 		.word	buffer_gps
 870 02e0 00000000 		.word	cont_string
 871 02e4 00000000 		.word	string_gps
 872 02e8 00000000 		.word	data_string_gps
 873 02ec 00000000 		.word	.LANCHOR0
 874 02f0 00000000 		.word	.LC14
 875 02f4 00000000 		.word	huart2
 876 02f8 54000000 		.word	.LC19
 877 02fc 00005940 		.word	1079574528
 878 0300 1C000000 		.word	.LC16
 879 0304 2C000000 		.word	.LC17
 880 0308 40000000 		.word	.LC18
 881 030c 00002440 		.word	1076101120
 882 0310 08000000 		.word	.LC15
 883              	.LVL82:
 884              	.L71:
 885              	.LBE10:
 886              	.LBE11:
 230:Src/gps.c     ****                     else if (string_gps[2] == 'V' && string_gps[3] == 'T' && string_gps[4] == 'G')
 887              		.loc 1 230 0 discriminator 1
 888 0314 484B     		ldr	r3, .L86
 889 0316 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 890 0318 542B     		cmp	r3, #84
 891 031a 7FF4CAAE 		bne	.L50
 230:Src/gps.c     ****                     else if (string_gps[2] == 'V' && string_gps[3] == 'T' && string_gps[4] == 'G')
 892              		.loc 1 230 0 is_stmt 0 discriminator 2
 893 031e 464B     		ldr	r3, .L86
 894 0320 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 895 0322 472B     		cmp	r3, #71
 896 0324 7FF4C5AE 		bne	.L50
 233:Src/gps.c     ****                         if (checksum(string_gps, cont_string) == 1)
 897              		.loc 1 233 0 is_stmt 1
 898 0328 444B     		ldr	r3, .L86+4
 899 032a 1968     		ldr	r1, [r3]
 900 032c 4248     		ldr	r0, .L86
 901 032e FFF7FEFF 		bl	checksum
 902              	.LVL83:
 903 0332 0646     		mov	r6, r0
ARM GAS  /tmp/ccePSTld.s 			page 25


 904              	.LVL84:
 905 0334 0128     		cmp	r0, #1
 906 0336 10D0     		beq	.L80
 907              	.LBB12:
 282:Src/gps.c     ****                             sprintf(txt,"\r\nCHECKSUM FAIL\r\n");
 908              		.loc 1 282 0 discriminator 3
 909 0338 1EAE     		add	r6, sp, #120
 910 033a 414F     		ldr	r7, .L86+8
 911 033c 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 912 033e 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 913 0340 3B68     		ldr	r3, [r7]
 914 0342 3380     		strh	r3, [r6]	@ movhi
 283:Src/gps.c     ****                             HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 915              		.loc 1 283 0 discriminator 3
 916 0344 1EA8     		add	r0, sp, #120
 917 0346 FFF7FEFF 		bl	strlen
 918              	.LVL85:
 919 034a 0A23     		movs	r3, #10
 920 034c 82B2     		uxth	r2, r0
 921 034e 1EA9     		add	r1, sp, #120
 922 0350 3C48     		ldr	r0, .L86+12
 923 0352 FFF7FEFF 		bl	HAL_UART_Transmit
 924              	.LVL86:
 284:Src/gps.c     ****                             ret = 0; //checksum failed
 925              		.loc 1 284 0 discriminator 3
 926 0356 0026     		movs	r6, #0
 927 0358 ABE6     		b	.L50
 928              	.LVL87:
 929              	.L80:
 930              	.LBE12:
 931              	.LBB13:
 235:Src/gps.c     ****                             cont_comma = 0;
 932              		.loc 1 235 0
 933 035a 0023     		movs	r3, #0
 934 035c 3A4A     		ldr	r2, .L86+16
 935 035e 1360     		str	r3, [r2]
 936              	.LVL88:
 937              	.LBB14:
 238:Src/gps.c     ****                             for (int i = 5; i < cont_string; i++)
 938              		.loc 1 238 0
 939 0360 0522     		movs	r2, #5
 940              	.LBE14:
 237:Src/gps.c     ****                             int cont_true_track_mode = 0;
 941              		.loc 1 237 0
 942 0362 1946     		mov	r1, r3
 943              	.LBB15:
 238:Src/gps.c     ****                             for (int i = 5; i < cont_string; i++)
 944              		.loc 1 238 0
 945 0364 04E0     		b	.L52
 946              	.LVL89:
 947              	.L82:
 241:Src/gps.c     ****                                     cont_comma++;
 948              		.loc 1 241 0
 949 0366 384F     		ldr	r7, .L86+16
 950 0368 3868     		ldr	r0, [r7]
 951 036a 0130     		adds	r0, r0, #1
 952 036c 3860     		str	r0, [r7]
ARM GAS  /tmp/ccePSTld.s 			page 26


 953              	.LVL90:
 954              	.L54:
 238:Src/gps.c     ****                             for (int i = 5; i < cont_string; i++)
 955              		.loc 1 238 0 discriminator 2
 956 036e 0132     		adds	r2, r2, #1
 957              	.LVL91:
 958              	.L52:
 238:Src/gps.c     ****                             for (int i = 5; i < cont_string; i++)
 959              		.loc 1 238 0 is_stmt 0 discriminator 1
 960 0370 3248     		ldr	r0, .L86+4
 961 0372 D0F800E0 		ldr	lr, [r0]
 962 0376 7245     		cmp	r2, lr
 963 0378 16DA     		bge	.L81
 240:Src/gps.c     ****                                 if (string_gps[i] == ',')
 964              		.loc 1 240 0 is_stmt 1
 965 037a 2F48     		ldr	r0, .L86
 966 037c 875C     		ldrb	r7, [r0, r2]	@ zero_extendqisi2
 967 037e 2C2F     		cmp	r7, #44
 968 0380 F1D0     		beq	.L82
 244:Src/gps.c     ****                                     if (cont_comma == 1){
 969              		.loc 1 244 0
 970 0382 3148     		ldr	r0, .L86+16
 971 0384 0068     		ldr	r0, [r0]
 972 0386 0128     		cmp	r0, #1
 973 0388 05D0     		beq	.L83
 248:Src/gps.c     ****                                     else if (cont_comma == 7)
 974              		.loc 1 248 0
 975 038a 0728     		cmp	r0, #7
 976 038c 08D1     		bne	.L56
 250:Src/gps.c     ****                                         gps->speed[cont_speed] = string_gps[i];
 977              		.loc 1 250 0
 978 038e E818     		adds	r0, r5, r3
 979 0390 0771     		strb	r7, [r0, #4]
 251:Src/gps.c     ****                                         cont_speed++;
 980              		.loc 1 251 0
 981 0392 0133     		adds	r3, r3, #1
 982              	.LVL92:
 983 0394 EBE7     		b	.L54
 984              	.L83:
 245:Src/gps.c     ****                                         gps->true_track_mode[cont_true_track_mode] = string_gps[i];
 985              		.loc 1 245 0
 986 0396 6818     		adds	r0, r5, r1
 987 0398 80F85C70 		strb	r7, [r0, #92]
 246:Src/gps.c     ****                                         cont_true_track_mode++;
 988              		.loc 1 246 0
 989 039c 0131     		adds	r1, r1, #1
 990              	.LVL93:
 991 039e E6E7     		b	.L54
 992              	.L56:
 253:Src/gps.c     ****                                     else if (cont_comma == 8)
 993              		.loc 1 253 0
 994 03a0 0828     		cmp	r0, #8
 995 03a2 E4D1     		bne	.L54
 255:Src/gps.c     ****                                         i = cont_string;
 996              		.loc 1 255 0
 997 03a4 7246     		mov	r2, lr
 998              	.LVL94:
ARM GAS  /tmp/ccePSTld.s 			page 27


 999 03a6 E2E7     		b	.L54
 1000              	.LVL95:
 1001              	.L81:
 1002              	.LBE15:
 260:Src/gps.c     ****                             if (gps->fix_status == '0')
 1003              		.loc 1 260 0
 1004 03a8 95F87130 		ldrb	r3, [r5, #113]	@ zero_extendqisi2
 1005              	.LVL96:
 1006 03ac 302B     		cmp	r3, #48
 1007 03ae 14D1     		bne	.L58
 1008              	.LBB16:
 263:Src/gps.c     ****                                 sprintf(txt,"\r\nNO CONNECTION\r\n");
 1009              		.loc 1 263 0
 1010 03b0 1EAF     		add	r7, sp, #120
 1011 03b2 DFF8A8E0 		ldr	lr, .L86+36
 1012 03b6 BEE80F00 		ldmia	lr!, {r0, r1, r2, r3}
 1013              	.LVL97:
 1014 03ba 0FC7     		stmia	r7!, {r0, r1, r2, r3}
 1015 03bc DEF80030 		ldr	r3, [lr]
 1016 03c0 3B80     		strh	r3, [r7]	@ movhi
 264:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 1017              		.loc 1 264 0
 1018 03c2 1EA8     		add	r0, sp, #120
 1019 03c4 FFF7FEFF 		bl	strlen
 1020              	.LVL98:
 1021 03c8 0A23     		movs	r3, #10
 1022 03ca 82B2     		uxth	r2, r0
 1023 03cc 1EA9     		add	r1, sp, #120
 1024 03ce 1D48     		ldr	r0, .L86+12
 1025 03d0 FFF7FEFF 		bl	HAL_UART_Transmit
 1026              	.LVL99:
 265:Src/gps.c     ****                                 gps->speed_i = 0;
 1027              		.loc 1 265 0
 1028 03d4 0023     		movs	r3, #0
 1029 03d6 EB60     		str	r3, [r5, #12]
 1030              	.LBE16:
 1031 03d8 6BE6     		b	.L50
 1032              	.LVL100:
 1033              	.L58:
 1034              	.LBB17:
 270:Src/gps.c     ****                                 gps->speed_i = (int)(atof(gps->speed) * 100);
 1035              		.loc 1 270 0
 1036 03da 281D     		adds	r0, r5, #4
 1037 03dc FFF7FEFF 		bl	atof
 1038              	.LVL101:
 1039 03e0 0022     		movs	r2, #0
 1040 03e2 1A4B     		ldr	r3, .L86+20
 1041 03e4 51EC100B 		vmov	r0, r1, d0
 1042 03e8 FFF7FEFF 		bl	__aeabi_dmul
 1043              	.LVL102:
 1044 03ec FFF7FEFF 		bl	__aeabi_d2iz
 1045              	.LVL103:
 1046 03f0 E860     		str	r0, [r5, #12]
 271:Src/gps.c     ****                                 gps->true_track_mode_i = (int)(atof(gps->true_track_mode)*10);
 1047              		.loc 1 271 0
 1048 03f2 05F15C00 		add	r0, r5, #92
 1049 03f6 FFF7FEFF 		bl	atof
ARM GAS  /tmp/ccePSTld.s 			page 28


 1050              	.LVL104:
 1051 03fa 0022     		movs	r2, #0
 1052 03fc 144B     		ldr	r3, .L86+24
 1053 03fe 51EC100B 		vmov	r0, r1, d0
 1054 0402 FFF7FEFF 		bl	__aeabi_dmul
 1055              	.LVL105:
 1056 0406 FFF7FEFF 		bl	__aeabi_d2iz
 1057              	.LVL106:
 1058 040a 6866     		str	r0, [r5, #100]
 273:Src/gps.c     ****                                 sprintf(txt,"speed: %d",gps->speed_i);
 1059              		.loc 1 273 0
 1060 040c EA68     		ldr	r2, [r5, #12]
 1061 040e 1149     		ldr	r1, .L86+28
 1062 0410 1EA8     		add	r0, sp, #120
 1063 0412 FFF7FEFF 		bl	sprintf
 1064              	.LVL107:
 274:Src/gps.c     ****                                 HAL_UART_Transmit(&huart2,(uint8_t*)txt,strlen(txt),10);
 1065              		.loc 1 274 0
 1066 0416 1EA8     		add	r0, sp, #120
 1067 0418 FFF7FEFF 		bl	strlen
 1068              	.LVL108:
 1069 041c 0A23     		movs	r3, #10
 1070 041e 82B2     		uxth	r2, r0
 1071 0420 1EA9     		add	r1, sp, #120
 1072 0422 0848     		ldr	r0, .L86+12
 1073 0424 FFF7FEFF 		bl	HAL_UART_Transmit
 1074              	.LVL109:
 1075 0428 43E6     		b	.L50
 1076              	.LVL110:
 1077              	.L68:
 1078              	.LBE17:
 1079              	.LBE13:
 1080              	.LBE5:
 1081              	.LBE4:
 303:Src/gps.c     ****         msg_arrived = 0;
 1082              		.loc 1 303 0
 1083 042a 0022     		movs	r2, #0
 1084 042c 0A4B     		ldr	r3, .L86+32
 1085 042e 1A60     		str	r2, [r3]
 1086              	.LVL111:
 1087              	.L27:
 307:Src/gps.c     **** }
 1088              		.loc 1 307 0
 1089 0430 3046     		mov	r0, r6
 1090 0432 44B0     		add	sp, sp, #272
 1091              	.LCFI7:
 1092              		.cfi_def_cfa_offset 24
 1093              		@ sp needed
 1094 0434 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1095              	.L87:
 1096              		.align	2
 1097              	.L86:
 1098 0438 00000000 		.word	string_gps
 1099 043c 00000000 		.word	cont_string
 1100 0440 54000000 		.word	.LC19
 1101 0444 00000000 		.word	huart2
 1102 0448 00000000 		.word	cont_comma
ARM GAS  /tmp/ccePSTld.s 			page 29


 1103 044c 00005940 		.word	1079574528
 1104 0450 00002440 		.word	1076101120
 1105 0454 68000000 		.word	.LC20
 1106 0458 00000000 		.word	msg_arrived
 1107 045c 08000000 		.word	.LC15
 1108              		.cfi_endproc
 1109              	.LFE132:
 1111              		.global	msg_arrived_s
 1112              		.comm	data_string_gps,1,1
 1113              		.comm	cont_comma,4,4
 1114              		.comm	cont_string,4,4
 1115              		.comm	string_gps,100,4
 1116              		.global	start_string_gps
 1117              		.section	.bss.msg_arrived_s,"aw",%nobits
 1118              		.align	2
 1121              	msg_arrived_s:
 1122 0000 00000000 		.space	4
 1123              		.section	.bss.start_string_gps,"aw",%nobits
 1124              		.align	2
 1125              		.set	.LANCHOR0,. + 0
 1128              	start_string_gps:
 1129 0000 00000000 		.space	4
 1130              		.section	.rodata.checksum.str1.4,"aMS",%progbits,1
 1131              		.align	2
 1132              	.LC0:
 1133 0000 20202578 		.ascii	"  %x  \000"
 1133      202000
 1134              		.section	.rodata.gps_init.str1.4,"aMS",%progbits,1
 1135              		.align	2
 1136              	.LC1:
 1137 0000 4552524F 		.ascii	"ERRORE 3\015\012\000"
 1137      52452033 
 1137      0D0A00
 1138 000b 00       		.space	1
 1139              	.LC2:
 1140 000c 4552524F 		.ascii	"ERRORE 4\015\012\000"
 1140      52452034 
 1140      0D0A00
 1141 0017 00       		.space	1
 1142              	.LC3:
 1143 0018 24504D54 		.ascii	"$PMTK251,115200*1F\015\012\000"
 1143      4B323531 
 1143      2C313135 
 1143      3230302A 
 1143      31460D0A 
 1144 002d 000000   		.space	3
 1145              	.LC4:
 1146 0030 4552524F 		.ascii	"ERRORE 6\015\012\000"
 1146      52452036 
 1146      0D0A00
 1147 003b 00       		.space	1
 1148              	.LC5:
 1149 003c 24504D54 		.ascii	"$PMTK220,100*2F\015\012\000"
 1149      4B323230 
 1149      2C313030 
 1149      2A32460D 
 1149      0A00
ARM GAS  /tmp/ccePSTld.s 			page 30


 1150 004e 0000     		.space	2
 1151              	.LC6:
 1152 0050 24504D54 		.ascii	"$PMTK314,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*28\015"
 1152      4B333134 
 1152      2C302C30 
 1152      2C312C31 
 1152      2C302C30 
 1153 0082 0A00     		.ascii	"\012\000"
 1154              	.LC7:
 1155 0084 3030302E 		.ascii	"000.00\000"
 1155      303000
 1156 008b 00       		.space	1
 1157              	.LC8:
 1158 008c 30303030 		.ascii	"0000.0000\000"
 1158      2E303030 
 1158      3000
 1159 0096 0000     		.space	2
 1160              	.LC9:
 1161 0098 4E00     		.ascii	"N\000"
 1162 009a 0000     		.space	2
 1163              	.LC10:
 1164 009c 30303030 		.ascii	"00000.0000\000"
 1164      302E3030 
 1164      303000
 1165 00a7 00       		.space	1
 1166              	.LC11:
 1167 00a8 5700     		.ascii	"W\000"
 1168 00aa 0000     		.space	2
 1169              	.LC12:
 1170 00ac 30303030 		.ascii	"0000.0\000"
 1170      2E3000
 1171 00b3 00       		.space	1
 1172              	.LC13:
 1173 00b4 303000   		.ascii	"00\000"
 1174              		.section	.rodata.gps_read.str1.4,"aMS",%progbits,1
 1175              		.align	2
 1176              	.LC14:
 1177 0000 25730D0A 		.ascii	"%s\015\012\000"
 1177      00
 1178 0005 000000   		.space	3
 1179              	.LC15:
 1180 0008 0D0A4E4F 		.ascii	"\015\012NO CONNECTION\015\012\000"
 1180      20434F4E 
 1180      4E454354 
 1180      494F4E0D 
 1180      0A00
 1181 001a 0000     		.space	2
 1182              	.LC16:
 1183 001c 6C617469 		.ascii	"latitude %ld %c\000"
 1183      74756465 
 1183      20256C64 
 1183      20256300 
 1184              	.LC17:
 1185 002c 6C6F6E67 		.ascii	"longitude %ld %c\000"
 1185      69747564 
 1185      6520256C 
 1185      64202563 
ARM GAS  /tmp/ccePSTld.s 			page 31


 1185      00
 1186 003d 000000   		.space	3
 1187              	.LC18:
 1188 0040 74696D65 		.ascii	"time %c%c:%c%c:%c%c\000"
 1188      20256325 
 1188      633A2563 
 1188      25633A25 
 1188      63256300 
 1189              	.LC19:
 1190 0054 0D0A4348 		.ascii	"\015\012CHECKSUM FAIL\015\012\000"
 1190      45434B53 
 1190      554D2046 
 1190      41494C0D 
 1190      0A00
 1191 0066 0000     		.space	2
 1192              	.LC20:
 1193 0068 73706565 		.ascii	"speed: %d\000"
 1193      643A2025 
 1193      6400
 1194              		.text
 1195              	.Letext0:
 1196              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1197              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1198              		.file 4 "Drivers/CMSIS/Include/core_cm4.h"
 1199              		.file 5 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/system_stm32f4xx.h"
 1200              		.file 6 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f411xe.h"
 1201              		.file 7 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 1202              		.file 8 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 1203              		.file 9 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 1204              		.file 10 "/usr/include/newlib/sys/lock.h"
 1205              		.file 11 "/usr/include/newlib/sys/_types.h"
 1206              		.file 12 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 1207              		.file 13 "/usr/include/newlib/sys/reent.h"
 1208              		.file 14 "/usr/include/newlib/stdlib.h"
 1209              		.file 15 "Inc/gps.h"
 1210              		.file 16 "/usr/include/newlib/stdio.h"
 1211              		.file 17 "/usr/include/newlib/string.h"
 1212              		.file 18 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
ARM GAS  /tmp/ccePSTld.s 			page 32


DEFINED SYMBOLS
                            *ABS*:0000000000000000 gps.c
     /tmp/ccePSTld.s:18     .text.checksum:0000000000000000 $t
     /tmp/ccePSTld.s:24     .text.checksum:0000000000000000 checksum
     /tmp/ccePSTld.s:166    .text.checksum:000000000000009c $d
     /tmp/ccePSTld.s:172    .text.gps_init:0000000000000000 $t
     /tmp/ccePSTld.s:179    .text.gps_init:0000000000000000 gps_init
     /tmp/ccePSTld.s:351    .text.gps_init:0000000000000118 $d
     /tmp/ccePSTld.s:371    .text.gps_read:0000000000000000 $t
     /tmp/ccePSTld.s:378    .text.gps_read:0000000000000000 gps_read
     /tmp/ccePSTld.s:868    .text.gps_read:00000000000002d8 $d
                            *COM*:0000000000000004 cont_string
                            *COM*:0000000000000064 string_gps
                            *COM*:0000000000000001 data_string_gps
     /tmp/ccePSTld.s:888    .text.gps_read:0000000000000314 $t
     /tmp/ccePSTld.s:1098   .text.gps_read:0000000000000438 $d
                            *COM*:0000000000000004 cont_comma
     /tmp/ccePSTld.s:1121   .bss.msg_arrived_s:0000000000000000 msg_arrived_s
     /tmp/ccePSTld.s:1128   .bss.start_string_gps:0000000000000000 start_string_gps
     /tmp/ccePSTld.s:1118   .bss.msg_arrived_s:0000000000000000 $d
     /tmp/ccePSTld.s:1124   .bss.start_string_gps:0000000000000000 $d
     /tmp/ccePSTld.s:1131   .rodata.checksum.str1.4:0000000000000000 $d
     /tmp/ccePSTld.s:1135   .rodata.gps_init.str1.4:0000000000000000 $d
     /tmp/ccePSTld.s:1175   .rodata.gps_read.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
sprintf
strlen
HAL_UART_Transmit
huart2
HAL_UART_DeInit
HAL_UART_Init
HAL_Delay
__aeabi_dmul
__aeabi_d2iz
atof
msg_arrived
buffer_gps
